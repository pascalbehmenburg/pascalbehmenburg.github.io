<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><meta http-equiv=X-UA-Compatible content=ie=edge><title>How This Blog Was Made</title><link rel=stylesheet href=./main.css><link rel=icon href=./favicon.ico type=image/x-icon><body><nav><a href=/index.html>Pascal</a><a href=/about.html>About</a></nav><main style="padding: 2%;"><article><h2 id=how-this-blog-was-made>How This Blog Comes to Life [<a href=/how_this_blog_was_made.html#how-this-blog-was-made style="text-decoration: none;">#</a>]</h2><p><sub>written on July 21, 2025 by Pascal Behmenburg</sub><hr><h3 id=whats-the-big-idea>What’s the Big Idea? [<a href=/how_this_blog_was_made.html#whats-the-big-idea style="text-decoration: none;">#</a>]</h3><p>I wanted a live Markdown-to-HTML server that updates on the fly, no rebuilds, no headaches. My must-haves:<ul><li><dl><dt><strong>Instant Rendering</strong><dd>Markdown files served as HTML with handy, shareable header links</dl><li><dl><dt><strong>Dynamic Feed</strong><dd>Auto-generated list of posts from a folder</dl><li><dl><dt><strong>Hot Reload</strong><dd>Edit a post, refresh the page, see changes immediately</dl></ul><p>Static site generators are cool, but I craved real-time feedback. So I choose Dioxus (Rust’s React sibling) to glue it all together. I may later on toggle on static-site generation for production, but for writing, I prefer the flexibility of a live server.<h3 id=markdown-parsing-with-pulldown-cmark>Markdown Parsing with pulldown-cmark [<a href=/how_this_blog_was_made.html#markdown-parsing-with-pulldown-cmark style="text-decoration: none;">#</a>]</h3><hr><p>I chose <a href=https://github.com/pulldown-cmark/pulldown-cmark>pulldown-cmark</a> for its speed and extensibility. <a href=https://github.com/pulldown-cmark/pulldown-cmark>pulldown-cmark</a> makes it possible to intercept the parsing via an Event-driven API and modify the HTML output for headers to our liking.<pre><code class=language-rs>pub fn parse_blog_markdown(blog_id: &str, markdown: &str, is_preview: bool) -> String {
    let parser = build_parser(markdown);

    let html_content = |content: String| Event::Html(CowStr::from(content));
    let text_content = |content: &'static str| Event::Text(CowStr::from(content));

    let mut heading = String::new();
    let parser = parser.flat_map(|event| match event {
        Event::Start(Tag::Heading {
            level,
            id: Some(heading_id),
            classes: _,
            attrs: _,
        }) => {
            if is_preview {
                vec![html_content(format!(
                    "&LTa href=\"/blog/{}#{}\"><{} id=\"{}\">",
                    blog_id, heading_id, level, heading_id
                ))]
            } else {
                heading = heading_id.to_string();
                vec![html_content(format!("<{} id=\"{}\">", level, heading_id))]
            }
        }
        Event::End(TagEnd::Heading(level)) => {
            if !is_preview {
                let events = vec![
                    text_content(" ["),
                    html_content(format!(
                        "&LTa href=\"/blog/{}#{}\" style=\"text-decoration: none;\">#&LT/a>",
                        blog_id, heading
                    )),
                    text_content("]"),
                    html_content(format!("&LT/{}>", level)),
                ];
                heading.clear();
                events
            } else {
                vec![html_content(format!("&LT/{}>&LT/a>", level))]
            }
        }
        _ => vec![event],
    });

    let mut html_output = String::new();
    html::push_html(&mut html_output, parser);
    html_output
}
</code></pre><h3 id=api>The API [<a href=/how_this_blog_was_made.html#api style="text-decoration: none;">#</a>]</h3><hr><p>Three server functions fetch IDs, full posts, and 3-line previews straight from a directory of markdown files:<pre><code class=language-rs>#[server(Blog)]
pub async fn blog(blog_id: String) -> Result&LTString, ServerFnError> {
    Ok(parse_blog_markdown(
        &blog_id,
        &get_blog_by_id(&blog_id).await?,
        false,
    ))
}

#[server(Feed)]
pub async fn get_blog_ids() -> Result&LTVec&LTString>, ServerFnError> {
    Ok(WalkDir::new(BLOG_POST_PATH)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .filter_map(|e| {
            e.path()
                .file_stem()
                .map(|stem| stem.to_string_lossy().to_string())
        })
        .collect::&LTVec&LTString>>())
}

#[server(BlogPreview)]
pub async fn blog_preview(blog_id: String) -> Result&LTString, ServerFnError> {
    let content = fs::read_to_string(format!("{}/{}.md", BLOG_POST_PATH, blog_id))?;
    let lines: Vec<&str> = content.lines().take(3).collect();
    let preview_md = lines.join("\n");
    let html = parse_blog_markdown(&blog_id, &preview_md, true);
    Ok(html)
}
</code></pre><h3 id=dioxus-components>Dioxus Components [<a href=/how_this_blog_was_made.html#dioxus-components style="text-decoration: none;">#</a>]</h3><hr><p>I built three components mirroring React patterns:<ul><li><dl><dt><strong>Feed</strong><dd>Grabs IDs, loops through previews</dl><li><dl><dt><strong>BlogPreview</strong><dd>Shows the 3-line teaser</dl><li><dl><dt><strong>BlogPost</strong><dd>Renders full post with dangerous_inner_html</dl></ul><pre><code class=language-rs>#[component]
pub fn Feed() -> Element {
    let blog_ids = use_server_future(api::get_blog_ids)?()
        .unwrap()
        .unwrap_or_default();

    rsx! {
        div {
            {blog_ids.iter().map(|id| {
                rsx! {
                    BlogPreview { id: id },
                    hr { width: "100%", size: "10"  }
                }
            })}
        }
    }
}

#[component]
pub fn BlogPreview(id: String) -> Element {
    let div_id = format!("blog-preview-{}", id);
    let html = use_server_future(move || api::blog_preview(id.clone()))?()
        .unwrap()
        .unwrap_or_default();

    rsx! {
        div {
            class: "{div_id}",
            dangerous_inner_html: "{html}",
        },
    }
}

#[component]
pub fn Blog(id: String) -> Element {
    let div_id = format!("blog-{}", id);
    let html = use_server_future(move || api::blog(String::from(&id)))?()
        .unwrap()
        .unwrap_or_default();

    rsx! {
        div {
            id: "{div_id}",
            dangerous_inner_html: "{html}"
        }
    }
}
</code></pre><h3 id=styling-syntax>Styling & Syntax [<a href=/how_this_blog_was_made.html#styling-syntax style="text-decoration: none;">#</a>]</h3><hr><ul><li><strong>No-Class CSS</strong>: I tweaked <a href=https://concrete.style/>concrete.css</a> for responsive layouts and punchy link colors<li><strong>Syntax Highlighting</strong>: Plugged in a subset of languages supported by <a href=https://highlightjs.org/>highlight.js</a> with two Base16 themes—light or dark, your choice</ul><p>That is all the magic there is to building a blog, as the one you’re reading right now!</article></main>